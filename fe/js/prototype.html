<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型和原型链 | 爱吃草莓的土豆怪</title>
    <meta name="description" content="follow your heart">
    <link rel="icon" href="/lee.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.cf2a1de2.css" as="style"><link rel="preload" href="/assets/js/app.847c0f1d.js" as="script"><link rel="preload" href="/assets/js/17.f47f37c7.js" as="script"><link rel="prefetch" href="/assets/js/10.719f85b6.js"><link rel="prefetch" href="/assets/js/11.f9aa89f9.js"><link rel="prefetch" href="/assets/js/12.815ee849.js"><link rel="prefetch" href="/assets/js/13.5bc913d5.js"><link rel="prefetch" href="/assets/js/14.9b582262.js"><link rel="prefetch" href="/assets/js/15.a86fc5a9.js"><link rel="prefetch" href="/assets/js/16.98ec5833.js"><link rel="prefetch" href="/assets/js/18.e9ff0407.js"><link rel="prefetch" href="/assets/js/19.c0e2a0ba.js"><link rel="prefetch" href="/assets/js/2.986b2112.js"><link rel="prefetch" href="/assets/js/20.fca73a61.js"><link rel="prefetch" href="/assets/js/3.15484a98.js"><link rel="prefetch" href="/assets/js/4.95246db9.js"><link rel="prefetch" href="/assets/js/5.b41ec6ec.js"><link rel="prefetch" href="/assets/js/6.bd34c90d.js"><link rel="prefetch" href="/assets/js/7.f655f2e5.js"><link rel="prefetch" href="/assets/js/8.300f85d4.js"><link rel="prefetch" href="/assets/js/9.84fb7fb4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cf2a1de2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">爱吃草莓的土豆怪</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/fe/" class="nav-link router-link-active">前端</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/fe/" class="nav-link router-link-active">前端</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/fe/" aria-current="page" class="sidebar-link">前端</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>JS</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/fe/js/arrayDeduplication.html" class="sidebar-link">数组去重</a></li><li><a href="/fe/js/prototype.html" aria-current="page" class="active sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe/js/inheritance.html" class="sidebar-link">继承方法</a></li><li><a href="/fe/js/发现alert的好用之处.html" class="sidebar-link">调试方法 - alert</a></li><li><a href="/fe/js/数组扁平化处理.html" class="sidebar-link">数组扁平化处理</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h3 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h3> <ul><li>什么是原型？</li> <li>原型链是什么？</li> <li>如何实现原型链？</li></ul> <h4 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h4> <p>构造函数: 使用 new 调用生成实例的函数。可以使用构造函数创建对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Idol</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">var</span> lee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Idol</span><span class="token punctuation">(</span><span class="token string">'lee'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h4> <p>每一个函数都有 <code>prototype</code> 属性，函数的 <code>prototype</code> 指向一个对象。这个对象就是调用该构造函数创建的实例的原型。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Idol</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token class-name">Idol</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'idol'</span>
<span class="token class-name">Idol</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">skill</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'帅'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> lee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Idol</span><span class="token punctuation">(</span><span class="token string">'lee'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Idol</span><span class="token punctuation">(</span><span class="token string">'vim'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从上面的例子看，Idol.prototype 就是实例 lee 和 vim 的原型。<br>
那么原型到底是什么呢？每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另外一个对象，这个与之关联的对象就是原型。每一个对象从原型中“继承”属性。</p> <p>那么它们到底怎么关联的呢？</p> <h4 id="proto"><a href="#proto" class="header-anchor">#</a> <code>__proto__</code></h4> <p>每一个 JavaScript 对象（null 除外）都具有一个属性 <code>__proto__</code>, 这个属性指向对象的原型。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Idol</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">var</span> lee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Idol</span><span class="token punctuation">(</span><span class="token string">'lee'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lee<span class="token punctuation">.</span>__proto__  <span class="token operator">===</span> <span class="token class-name">Idol</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>到目前为止，构造函数有一个属性 <code>prototype</code> 指向原型，实例有 <code>__proto__</code> 指向原型，那么原型是否也有属性构造函数和实例对象呢？</p> <h4 id="constructor"><a href="#constructor" class="header-anchor">#</a> <code>constructor</code></h4> <p>原型指向实例对象的属性，其实也不必需要。原型都有一个属性 <code>constructor</code> 指向关联的构造函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Idol</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Idol  <span class="token operator">===</span> <span class="token class-name">Idol</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那么这样子我们就可以得到了构造函数、原型和实例对象之间的关系。<br>
通过上面的分析，我们可以得出三者的关系如下图：<br> <img src="https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype1.png" alt="Aaron Swartz"></p> <h4 id="实例与原型"><a href="#实例与原型" class="header-anchor">#</a> 实例与原型</h4> <p>我们着重来分析一下实例和原型的关系，实例是从原型上“继承”属性，那么怎么继承呢？
先来看一下例子吧。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Idol</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token class-name">Idol</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'idol'</span>

<span class="token keyword">var</span> lee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Idol</span><span class="token punctuation">(</span><span class="token string">'lee'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lee<span class="token punctuation">.</span>type<span class="token punctuation">)</span>  <span class="token comment">// 'idol'</span>

lee<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'actor'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lee<span class="token punctuation">.</span>type<span class="token punctuation">)</span>  <span class="token comment">// 'actor'</span>

<span class="token keyword">delete</span> lee<span class="token punctuation">.</span>type
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lee<span class="token punctuation">.</span>type<span class="token punctuation">)</span>  <span class="token comment">// 'idol'</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>从上面的例子可以看出，第一次打印 lee.type 的时候，虽然 lee 对象本身没有 type 属性，但是它的原型拥有 type 属性，lee “继承” 它的原型的 type 属性，所以第一次打印的结果是 idol；接下来我们给 lee 对象添加一个 type 属性，再打印一次 lee.name， 这时 lee 对象本身就有 type 属性，就不再去找原型上面找 type，打印结果为 actor；接下来我们删除了 lee 的 type 属性。这是 lee 本身没有 type 属性了，所以需要去原型上找，原型拥有 type 的属性，所以第三次的打印结果为 idol。<br>
这里我们可以得出一个结论：优先访问实例中的属性，如果实例中没有的属性，则去原型上找。</p> <p>如果没有原型上没有找到相应的属性呢？</p> <h4 id="原型的原型"><a href="#原型的原型" class="header-anchor">#</a> 原型的原型</h4> <p>其实原型也是一个对象，原型对象是通过 Object 构造函数生成，也就是说原型的 <code>__proto__</code> 指向 Object.prototype。
这样子关系应该更新为
<img src="https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype2.png" alt="Aaron Swartz"></p> <p>那么 Object.prototype 的原型是什么呢？</p> <h4 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h4> <p>Object.prototype 的 <code>__prpro__</code> 指向 null。Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>null 是表示缺少的标识，指示变量未指向任何对象。也就是说 Object.prototype 没有原型。<br>
关系图更新为:
<img src="https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype3.png" alt="Aaron Swartz"></p> <p>那么原型链是什么呢？<br>
每一个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。也就是说原型链是基于 <code>__proto__</code> 实现。</p> <p>有个问题，你发现了吗？构造函数从何而来？</p> <h4 id="构造函数的原型链"><a href="#构造函数的原型链" class="header-anchor">#</a> 构造函数的原型链</h4> <ul><li>任何函数都是由 new Function 创建。也就是说所有的构造函数的 <code>__proto__</code> 都是指向 Function.prototype。</li> <li>Function.prototype 对象是一个函数（对象），其 [[Prototype]] 内部属性值指向内建对象 Object.prototype。Function.prototype 没有 prototype 属性。<code>Function.prototype.__proto__ === Object.prototype</code>。<br>
那么关系图可以更新为:
<img src="https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype5.png" alt="Aaron Swartz"></li></ul> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <ul><li>每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另外一个对象，这个与之关联的对象就是<strong>原型</strong>。每一个对象从原型中“继承”属性。</li> <li>每一个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为<strong>原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。也就是说原型链是基于 <code>__proto__</code> 实现。</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/fe/js/arrayDeduplication.html" class="prev">
          数组去重
        </a></span> <span class="next"><a href="/fe/js/inheritance.html">
          继承方法
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.847c0f1d.js" defer></script><script src="/assets/js/17.f47f37c7.js" defer></script>
  </body>
</html>
